import asyncio
import os
import json
import streamlit as st
from datetime import date
from google import genai
from google.genai import types
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
from dotenv import load_dotenv

load_dotenv()

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
SERP_API_KEY = os.getenv("SERP_API_KEY")

if not GEMINI_API_KEY:
    raise ValueError("GEMINI_API_KEY environment variable not set")

if not SERP_API_KEY:
    raise ValueError("SERP_API_KEY environment variable not set")

# Initialize Gemini client
client = genai.Client(api_key=GEMINI_API_KEY)

# Configure MCP stdio connection
server_params = StdioServerParameters(
    command="mcp-flight-search",
    args=["--connection_type", "stdio"],
    env={"SERP_API_KEY": SERP_API_KEY},
)

# Async function to fetch flight data
async def fetch_flight_data(user_prompt: str):
    async with stdio_client(server_params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()
            mcp_tools = await session.list_tools()

            tools = [
                types.Tool(
                    function_declarations=[
                        {
                            "name": tool.name,
                            "description": tool.description,
                            "parameters": {
                                k: v
                                for k, v in tool.inputSchema.items()
                                if k not in ["additionalProperties", "$schema"]
                            },
                        }
                    ]
                )
                for tool in mcp_tools.tools
            ]

            # Call Gemini
            response = client.models.generate_content(
                model="gemini-2.5-pro-exp-03-25",
                contents=user_prompt,
                config=types.GenerateContentConfig(
                    temperature=0,
                    tools=tools,
                ),
            )

            # Safely extract function call
            function_call = None
            candidate = response.candidates[0] if response.candidates else None

            if candidate and hasattr(candidate, "content"):
                for part in candidate.content.parts:
                    if hasattr(part, "function_call") and part.function_call:
                        function_call = part.function_call
                        break

            if function_call:
                # Run tool with arguments
                result = await session.call_tool(
                    function_call.name, arguments=dict(function_call.args)
                )
                try:
                    return json.loads(result.content[0].text)
                except json.JSONDecodeError:
                    return {"error": "Response not in JSON format", "raw": result.content[0].text}
                except (IndexError, AttributeError):
                    return {"error": "Unexpected result format", "raw": str(result)}
            else:
                return {
                    "error": "No function call generated by model",
                    "raw": str(candidate.text) if candidate and hasattr(candidate, "text") else "No text available"
                }

# Streamlit UI
st.set_page_config(page_title="Flight Search Assistant", page_icon="‚úàÔ∏è")
st.title("‚úàÔ∏è Flight Search Assistant")

# User Input Form
with st.form("flight_form"):
    origin = st.text_input("Departure City", "Atlanta")
    destination = st.text_input("Destination City", "Las Vegas")
    travel_date = st.date_input("Departure Date", value=date(2025, 5, 5), min_value=date.today())
    submitted = st.form_submit_button("Search Flights")

if submitted:
    query = f"Find flights from {origin} to {destination} on {travel_date}"
    with st.spinner("Please wait..."):
        flight_result = asyncio.run(fetch_flight_data(query))

    st.markdown("## üßæ Search Results")

    # Error Handling
    if "error" in flight_result:
        st.error(flight_result["error"])
        if "raw" in flight_result:
            st.code(flight_result["raw"])
    else:
        # Handle multiple or single flight results
        flights = flight_result if isinstance(flight_result, list) else [flight_result]
        for i, flight in enumerate(flights, start=1):
            st.markdown(f"### ‚úàÔ∏è Flight {i}")
            if flight.get("airline_logo"):
                st.image(flight["airline_logo"], width=70)
            st.markdown(f"""
            **Airline**: {flight.get("airline", "N/A")}  
            **Price**: ${flight.get("price", "N/A")}  
            **Duration**: {flight.get("duration", "N/A")}  
            **Stops**: {flight.get("stops", "N/A")}  
            **Departure**: {flight.get("departure", "N/A")}  
            **Arrival**: {flight.get("arrival", "N/A")}  
            **Class**: {flight.get("travel_class", "N/A")}  
            """)
